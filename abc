





	std::cout << "Slam::update_depth_lsd5" << std::endl;

	if (!m_key || !m_frame) { return; }

	const double* t = m_frame->pos.val;

	int total = m_width * m_height;
	float* pit = (float*)m_key->residual->data();
	float* pd = (float*)m_key->depth->data();
	float* pw = (float*)m_key->depth_weight->data();
	float* piu = (float*)m_key->gradient[0]->data();
	float* piv = (float*)m_key->gradient[1]->data();
	unsigned char* pm = (unsigned char*)m_key->mask->data();


	 Intrinsic in = m_key->intrinsic;
	 double f1 = 1.0/in.f;
	 double w1, w2, m0[2], x[2], a, iu[2];

	for (int i = 0; i < total; i++) {

		if (!pm[i]) { continue; }

		m0[0] = i % m_width - in.cx;
		m0[1] = i / m_width - in.cy;
		x[0] = m0[0]*f1;
		x[1] = m0[1]*f1;

		iu[0] = piu[i];
		iu[1] = piv[i];
		w1 = pw[i];

		a = pd[i]*(iu[0]*t[0]+iu[1]*t[1]-
			(iu[0]*x[0]+iu[1]*x[1])*t[2]);
		w2 = a*a;
		pd[i] -= a*pit[i]*f1/(w1+w2);
		w1 = 0.5*(w1+w2);
		if (w1 < Config::min_depth_weight)
		{ w1 = Config::min_depth_weight; }
		pw[i] = w1;
	}

bool Slam::calc_e_dr_of3(bool only_dr/* = false*/) {


	std::cout << "Slam::calc_e_dr_of3" << std::endl;

	if (!m_key || !m_frame) { return true; }
	int total = m_width * m_height;
	Vec2f* put = (Vec2f*)m_of->data();
	float* pw = (float*)m_weight->data();
	Vec2f* pdut = (Vec2f*)m_dut->data();

	 Intrinsic in = m_key->intrinsic;
	 double f1 = 1.0 / in.f;
	 double m0[3], m1[3], x0[3], x1[3], x10[3];
	 Vec9d iR = MatrixToolbox::inv_matrix_3x3(m_frame->rotation);
	 const double* R = iR.val;
	 const double* e = m_frame->epi_point.val;
	 double c, w, ae[3], ar[3], ar0[3];
	 double Ae[9], Ar[9], Br[3];

	 memset(Ae, 0, sizeof(Ae));
	 memset(Ar, 0, sizeof(Ar));
	 memset(Br, 0, sizeof(Br));
 	 m0[2] = 1;
 	 m1[2] = 1;
	 x10[2] = 1;
	 x0[2] = 1;
	 x1[2] = 1;

	for (int i = 0; i < total; i++) {

		m0[0] = i % m_width - in.cx;
		m0[1] = i / m_width - in.cy;
		m1[0] = m0[0] + put[i][0];
		m1[1] = m0[1] + put[i][1];
		x0[0] = m0[0]*f1;
		x0[1] = m0[1]*f1;
		x10[0] = m1[0]*f1;
		x10[1] = m1[1]*f1;
		x1[0] = R[0]*x10[0]+R[1]*x10[1]+R[2]*x10[2];
		x1[1] = R[3]*x10[0]+R[4]*x10[1]+R[5]*x10[2];
		x1[2] = R[6]*x10[0]+R[7]*x10[1]+R[8]*x10[2];

		pdut[i][0] = x1[0]*in.f/x1[2]-m0[0];
		pdut[i][1] = x1[1]*in.f/x1[2]-m0[1];

		ae[0] = x0[1]*x1[2]-x0[2]*x1[1];
		ae[1] = x0[2]*x1[0]-x0[0]*x1[2];
		ae[2] = x0[0]*x1[1]-x0[1]*x1[0];

		c = ae[0]*e[0]+ae[1]*e[1]+ae[2]*e[2];
		w = exp(-c*c*Config::epi_sigma2_of3);
		pw[i] = w;

		Ae[0] += w*ae[0]*ae[0];
		Ae[1] += w*ae[0]*ae[1];
		Ae[2] += w*ae[0]*ae[2];
		Ae[4] += w*ae[1]*ae[1];
		Ae[5] += w*ae[1]*ae[2];
		Ae[8] += w*ae[2]*ae[2];

		ar0[0] = x1[1]*e[2]-x1[2]*e[1];
		ar0[1] = x1[2]*e[0]-x1[0]*e[2];
		ar0[2] = x1[0]*e[1]-x1[1]*e[0];

		ar[0] = x0[1]*ar0[2]-x0[2]*ar0[1];
		ar[1] = x0[2]*ar0[0]-x0[0]*ar0[2];
		ar[2] = x0[0]*ar0[1]-x0[1]*ar0[0];

		Ar[0] += w*ar[0]*ar[0];
		Ar[1] += w*ar[0]*ar[1];
		Ar[2] += w*ar[0]*ar[2];
		Ar[4] += w*ar[1]*ar[1];
		Ar[5] += w*ar[1]*ar[2];
		Ar[8] += w*ar[2]*ar[2];

		Br[0] -= w*c*ar[0];
		Br[1] -= w*c*ar[1];
		Br[2] -= w*c*ar[2];
	}

	Ae[3] = Ae[1];
	Ae[6] = Ae[2];
	Ae[7] = Ae[5];

	Ar[3] = Ar[1];
	Ar[6] = Ar[2];
	Ar[7] = Ar[5];
	
	//A /= total;
	//B /= total;

	Ar[0] += 0.1;
	Ar[4] += 0.1;
	Ar[8] += 0.1;


	if (!only_dr) {
		m_frame->epi_point = MatrixToolbox::min_eigen_vector_3x3(Ae);	
	}
	
	Vec9d iAr = MatrixToolbox::inv_matrix_3x3(Ar);
	double dr[3] = {
			iAr[0]*Br[0]+iAr[1]*Br[1]+iAr[2]*Br[2],
			iAr[3]*Br[0]+iAr[4]*Br[1]+iAr[5]*Br[2],
			iAr[6]*Br[0]+iAr[7]*Br[1]+iAr[8]*Br[2],

	};
	MatrixToolbox::update_rotation(m_frame->rotation, dr);
	m_frame->rotation_warp(m_key->warp);

	return true;
}

 m_trans_2d[0] *= 0.8; 
			u = x - center[0];
			v = x - center[1];
			w = 1.25;
			m_trans_2d[0] *= w;
			m_trans_2d[1] = w*m_trans_2d[0]+u-w*u;
			m_trans_2d[1] = w*m_trans_2d[1]+v-w*v;


b Slam.cpp:3435 if (u == 45 && v == 31)


bool Slam::calc_du_of4() {

	std::cout << "Slam::calc_du_of4" << std::endl;

	if (!m_key || !m_frame) { return true; }
	int total = m_width * m_height;
	float* pwit = (float*)m_key->residual->data();
	Vec2f* pdut = (Vec2f*)m_key->dut->data();
	Vec2f* put = (Vec2f*)m_key->optical_flow->data();

	Vec2f* pwiu1 = (Vec2f*)m_key->warp_gradient->data();
	float* piu0 = (float*)m_key->gradient[0]->data();
	float* piv0 = (float*)m_key->gradient[1]->data();
	float* pw = (float*)m_key->of_weight->data();
	unsigned char* pm = (unsigned char*)m_key->mask->data();

	int u, v, u2, v2;
	float w, W, iu0[2], iu1[2];//, d;
	double A[4], iA[4], B[2], it, iuu[2], idet, iuiu[4];
	double lamda = Config::du_smooth_lamda_of3;
	double s = Config::stable_factor_of3;

	int offid[9] = { 
		-m_width-1, -m_width, -m_width+1,
		-1, 0, 1,
		m_width-1, m_width, m_width+1
	};
	int offx[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };
	int offy[9] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };

	double a, b[2], c;

	for (int i = 0; i < total; i++) {


		u = i % m_width;
		v = i / m_width;

		iu0[0] = piu0[i];
		iu0[1] = piv0[i];
		it = pwit[i];
		c = iu0[0]*iu0[0]+iu0[1]*iu0[1];
		a = c;
		b[0] = -it*iu0[0];
		b[1] = -it*iu0[1];

		if (Config::use_i1_constrain_of3) {
			iu1[0] = pwiu1[i][0];
			iu1[1] = pwiu1[i][1];

			a += iu1[0]*iu1[0]+iu1[1]*iu1[1];
			b[0] -= it*iu1[0];
			b[1] -= it*iu1[1];			
		}


		for (int k = 0; k < 9; k++) {
			u2 = u + offx[k];
			v2 = v + offy[k];
			if (u2 >= 0 && u2 < m_width && v2 >= 0 && v2 < m_height) {

					iuu[0] = put[i+offid[k]][0]-put[i][0];
					iuu[1] = put[i+offid[k]][1]-put[i][1];
					w = pw[i+offid[k]] + Config::stable_factor_of3;
					w *= Config::du_smooth_lamda_of3;
					//w = Config::stable_factor_of3;;
					a += w;//*(c+0.5);
					b[0] += w*iuu[0];
					b[1] += w*iuu[1];
			}
		}

		pdut[i][0] = b[0]/(a+0.01);
		pdut[i][1] = b[1]/(a+0.01);

	}

	//return is ok?
	m_key->optical_flow->add(m_key->dut);
	return false;
}


bool Slam::calc_du_of4() {

	std::cout << "Slam::calc_du_of4" << std::endl;

	if (!m_key || !m_frame) { return true; }
	int total = m_width * m_height;
	float* pwit = (float*)m_key->residual->data();
	Vec2f* pdut = (Vec2f*)m_key->dut->data();
	Vec2f* put = (Vec2f*)m_key->optical_flow->data();

	Vec2f* pwiu1 = (Vec2f*)m_key->warp_gradient->data();
	float* piu0 = (float*)m_key->gradient[0]->data();
	float* piv0 = (float*)m_key->gradient[1]->data();
	float* pw = (float*)m_key->of_weight->data();
	unsigned char* pm = (unsigned char*)m_key->mask->data();

	int u, v, u2, v2;
	float w, W, iu0[2], iu1[2];//, d;
	double A[4], iA[4], B[2], it, iuu[2], idet, iuiu[4];
	double lamda = Config::du_smooth_lamda_of3;
	double s = Config::stable_factor_of3;

	int offid[9] = { 
		-m_width-1, -m_width, -m_width+1,
		-1, 0, 1,
		m_width-1, m_width, m_width+1
	};
	int offx[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };
	int offy[9] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };

	double a, b[2], c;

	for (int i = 0; i < total; i++) {


		u = i % m_width;
		v = i / m_width;

		iu0[0] = piu0[i];
		iu0[1] = piv0[i];
		it = pwit[i];
		c = iu0[0]*iu0[0]+iu0[1]*iu0[1];
		a = c;
		b[0] = it*iu0[0];
		b[1] = it*iu0[1];

		if (Config::use_i1_constrain_of3) {
			iu1[0] = pwiu1[i][0];
			iu1[1] = pwiu1[i][1];

			a += iu1[0]*iu1[0]+iu1[1]*iu1[1];
			b[0] += it*iu1[0];
			b[1] += it*iu1[1];			
		}


		for (int k = 0; k < 9; k++) {
			u2 = u + offx[k];
			v2 = v + offy[k];
			if (u2 >= 0 && u2 < m_width && v2 >= 0 && v2 < m_height) {

					iuu[0] = put[i+offid[k]][0]-put[i][0];
					iuu[1] = put[i+offid[k]][1]-put[i][1];
					w = pw[i+offid[k]] + Config::stable_factor_of3;
					a += w*(c+0.5);
					b[0] -= w*(c+0.5)*iuu[0];
					b[1] -= w*(c+0.5)*iuu[1];
			}
		}

		pdut[i][0] = -b[0]/(a+0.01);
		pdut[i][1] = -b[1]/(a+0.01);

	}

	//return is ok?
	m_key->optical_flow->add(m_key->dut);
	return false;
}



bool Slam::calc_du_of4() {

	std::cout << "Slam::calc_du_of3" << std::endl;

	if (!m_key || !m_frame) { return true; }
	int total = m_width * m_height;
	float* pwit = (float*)m_key->residual->data();
	Vec2f* pdut = (Vec2f*)m_key->dut->data();
	Vec2f* put = (Vec2f*)m_key->optical_flow->data();

	Vec2f* pwiu1 = (Vec2f*)m_key->warp_gradient->data();
	float* piu0 = (float*)m_key->gradient[0]->data();
	float* piv0 = (float*)m_key->gradient[1]->data();
	float* pw = (float*)m_key->of_weight->data();
	unsigned char* pm = (unsigned char*)m_key->mask->data();

	int u, v, u2, v2;
	float w, W, iu0[2], iu1[2];//, d;
	double A[4], iA[4], B[2], it, iuu[2], idet, iuiu[4];
	double lamda = Config::du_smooth_lamda_of3;
	double s = Config::stable_factor_of3;

	int offid[9] = { 
		-m_width-1, -m_width, -m_width+1,
		-1, 0, 1,
		m_width-1, m_width, m_width+1
	};
	int offx[9] = { -1, 0, 1, -1, 0, 1, -1, 0, 1 };
	int offy[9] = { -1, -1, -1, 0, 0, 0, 1, 1, 1 };

	for (int i = 0; i < total; i++) {

		u = i % m_width;
		v = i / m_width;

		memset(A, 0, sizeof(A));
		memset(B, 0, sizeof(B));

		for (int k = 0; k < 9; k++) {
			u2 = u + offx[k];
			v2 = v + offy[k];
			if (u2 >= 0 && u2 < m_width && v2 >= 0 && v2 < m_height) {

					iu0[0] = piu0[i+offid[k]];
					iu0[1] = piv0[i+offid[k]];
					iuu[0] = put[i+offid[k]][0]-put[i][0];
					iuu[1] = put[i+offid[k]][1]-put[i][1];
					w = pw[i+offid[k]];
					it = pwit[i+offid[k]];

					iuiu[0] = iu0[0]*iu0[0];
					iuiu[1] = iu0[0]*iu0[1];
					iuiu[2] = iu0[1]*iu0[0];
					iuiu[3] = iu0[1]*iu0[1];

					if (pm[i]) {
						A[0] += iuiu[0];
						A[1] += iuiu[1];
						//A[2] += iuiu[2];
						A[3] += iuiu[3];

						B[0] += iu0[0]*it;
						B[1] += iu0[1]*it;

					}

					if (Config::use_i1_constrain_of3) {
						
						iu1[0] = pwiu1[i+offid[k]][0];
						iu1[1] = pwiu1[i+offid[k]][1];
						A[0] += iu1[0]*iu1[0];
						A[1] += iu1[0]*iu1[1];
						//A[2] += iu1[1]*iu1[0];
						A[3] += iu1[1]*iu1[1];

						B[0] += iu1[0]*it;
						B[1] += iu1[1]*it;

					}

					if (Config::use_of_smooth_of4) {

						w += 0.001;
						iuiu[0] += s;
						iuiu[3] += s;

						A[0] += iuiu[0]*lamda*w;
						A[1] += iuiu[1]*lamda*w;
						//A[2] += iuiu[2]*lamda*w;
						A[3] += iuiu[3]*lamda*w;

						B[0] += -lamda*w*(iuiu[0]*iuu[0]+
							iuiu[1]*iuu[1]);
						B[1] += -lamda*w*(iuiu[2]*iuu[0]+
							iuiu[3]*iuu[1]);

						/*
						A[0] += lamda*(iuiu[0]*w+s);
						A[1] += lamda*(iuiu[1]*w);
						//A[2] += iuiu[2]*lamda*w;
						A[3] += lamda*(iuiu[3]*w+s);

						//A[0] += lamda*s;
						//A[3] += lamda*s;					

						//B[0] += -lamda*w*(iuiu[0]*iuu[0]+
						//	iuiu[1]*iuu[1]);
						//B[1] += -lamda*w*(iuiu[2]*iuu[0]+
						//	iuiu[3]*iuu[1]);

						B[0] -= lamda*s*iuu[0];
						B[1] -= lamda*s*iuu[1];
						*/
					}


			}
		}

		A[2] = A[1];

		//A[0] += s;
		/A[3] += s;


		idet = 1.0/(A[0]*A[3]-A[1]*A[2]);
		iA[0] = A[3]*idet;
		iA[1] = -A[2]*idet;
		iA[2] = -A[1]*idet;
		iA[3] = A[0] *idet;

		pdut[i][0] = -(iA[0]*B[0]+iA[1]*B[1]);
		pdut[i][1] = -(iA[2]*B[0]+iA[3]*B[1]);

	}

	//return is ok?
	m_key->optical_flow->add(m_key->dut);
	return false;
}


		//m_content->push_manauly();
		// m_content->build((ViewContent::BuildFlag)(
		// 	ViewContent::BuildAll - 
		// 	//ViewContent::BuildIterate -
		// 	ViewContent::BuildSequence
		// ));





/***************************



	const Intrinsic& intri0 = m_key->intrinsic;
	//float invf0 = 1 / m_key->intrinsic.f;
	const Intrinsic& intri1 = m_frame->intrinsic;
	
	const Vec9d& R = m_frame->rotation;

	int w = image->width();
	int h = image->height();
	m_key = new Camera();
	SpaceToolbox::init_intrinsic(m_key->intrinsic, 45, w, h);
	
	image->copy_to(m_key->original);
	image->gray(m_key->gray);
	m_key->depth = new CvImage(w, h, Image::Float32);

	m_key->depth->set(0.1);
	m_key->points = new CvImage(w, h, Image::Float32, 4);

	m_keyframes.push_back(m_key);
	m_cameras[m_camera_count] = m_key;

	m_camera_count++;


	if (m_key) {
		if (!m_frame) {
			int w = image->width();
			int h = image->height();
			m_frame = new Camera();
			SpaceToolbox::init_intrinsic(m_frame->intrinsic, 45, w, h);
		
			m_frame->points = new CvImage(w, h, Image::Float32, 4);
		}
		image->gray(m_frame->gray);
		m_frame->gray->sobel_x(m_frame->gradient[0]);
		m_frame->gray->sobel_y(m_frame->gradient[1]);

	}

			j = i + offset[k];
			//if (j < 0) { continue; }
			u2 = j % m_width;
			v2 = j / m_width;


	if (m_key == NULL) {
	
		int w = image->width();
		int h = image->height();
		m_key = new Camera();
		SpaceToolbox::init_intrinsic(m_key->intrinsic, 45, w, h);
		
		image->copy_to(m_key->original);
		image->gray(m_key->gray);
		m_key->depth = new CvImage(w, h, Image::Float32);

		m_key->depth->set(0.1);
		m_key->points = new CvImage(w, h, Image::Float32, 4);

		m_keyframes.push_back(m_key);
		m_cameras[m_camera_count] = m_key;
	
		m_camera_count++;
	}
	else {

		Vec2f* pGrad = (Vec2f*)m_gradient->data();
		float* pDg = (float*)m_residual->data();
		float* pDepth = (float*)m_depth->data();
		Vec4f* pPts = (Vec4f*)m_frame->points->data();
		unsigned char* pMask = (unsigned char*)m_mask->data();
		float* p_kd = (float*)m_key->depth->data();
		const Vec3d& t = m_frame->pos;
		int total = m_width * m_height;
		double a[3];
		double a2, temp;
		for (int i = 0; i < total; i++) {
			if (!pMask[i]) { continue; }
			temp = m_frame->intrinsic.f*pDepth[i]/p_kd[i];
			a[0] = pGrad[i][0]*temp;
			a[1] = pGrad[i][1]*temp;
			a[2] = -(a[0]*pPts[i][0]+a[1]*pPts[i][0]);
			a2 = a[0]*t[0]+a[1]*t[1]+a[2]*t[2];
			p_kd[i] += a2*pDg[i] / (100 + a2*a2);
		}
	}
	



	cv::minMaxIdx(image, &min, &max);
	scale = 1./(max-min);
	_image.convertTo(image, 
		CV_32FC(image.channels()), scale, -min/(max-min));		

	
	//MatrixToolbox::rectify_rotation(m_frame->rotation);

		
		
		//m_frame->gradient[0]->save("aaa.jpg");
		//m_frame->gradient[1]->save("bbb.jpg");
		//m_frame->gray->subtract(m_key->gray, m_frame->residual);
		
		
	
		// unprojects each pixel for calc delta
		int width = m_key->gray->width();
		int height = m_key->gray->height();
		
		
		int total = width * height;
		const Intrinsic& intri = m_key->intrinsic;
		float invf0 = 1 / intri.f;
		int u, v;
		Vec4f p;
		float* p_depth = (float*)m_key->depth->data();
		Vec4f* p_pts = (Vec4f*)m_key->points->data();

		for (int i = 0; i < total; i++) {
	
			u = i % width;
			v = i / width;
		
			p[0] = (u-intri.cx)*invf0;
			p[1] = (v-intri.cy)*invf0;
			p[2] = 1;
			p[3] = p_depth[i];
		
			p_pts[i] = p;
		}


		
	
	if (m_source->read(image)) {
		image->resize(resized);
		initialize(resized);
	}


		//if (delta_t.length2() < 0.0001) { break; }
		break;

		//image->convert_to(m_key->depth, Image::Float32);
				
		//memset(m_key->pos, 0, sizeof(m_key->pos));
		//m_key->image = image;
		//m_key->depth = default_depth; 

	short* pGx = (short*)m_frame->gradient[0]->data();
	short* pGy = (short*)m_frame->gradient[1]->data();
	short* pDg = (short*)m_frame->residual->data();
	float* pIz = (float*)m_key->depth->data();
	

	if (m_camera_count == 1) {
	
		m_cameras[m_camera_count] = m_frame;
		m_camera_count++;
	}
		
			p_grad[i][0] = m_frame->gradient[0]->sample(m[0], m[1]);
			p_grad[i][1] = m_frame->gradient[1]->sample(m[0], m[1]);
			
			p_dg[i] = p_gkey[i] - m_frame->gray->sample(m[0], m[1]);

m_frame->gray->sample(m[0], m[1]);

	m_mask->set(255);
	//m_mask->reset(width, height, Image::UnsignedChar);

	unsigned char* pGray = (unsigned char*)m_frame->gray->data();


	return Vec3d();
	
	//int width = image->width;
	//int height = image->height;
	
	//u = i % width;
	//v = i / width;
	
	
	
	
	//foreach(pixel) {
	
		// calc a;
		// calc b;
		// calc w;
		// A += w * a * a';
		// B += w * b;
	//}
	//return inv(A) * B;
	
	return Vec3d();


#include <unistd.h>
		//sleep(10);

void Slam::tick() {

	std::cout << "Slam::tick" << std::endl;


}


	Camera* camera1 = new Camera();
	camera1->pos[0] = 0;
	camera1->pos[1] = 0;
	camera1->pos[2] = 0;
	
	Camera* camera2 = new Camera();
	camera2->pos[0] = 100;
	camera2->pos[1] = 100;
	camera2->pos[2] = 100;
	
	m_keyframes.push_back(camera1);
	m_keyframes.push_back(camera2);
	
	m_cameras[0] = camera1;
	m_cameras[1] = camera2;
	
	m_camera_count = 2;



#include <stdio.h>
#include <stdio.h>

*********************************/




	if (Config::method == Of3) {
		build_of3();
	}
	else if (Config::method == Of4) {
		build_of4();
	}


void Slam::step(StepFlag flag/* = StepAll*/) {
	
}


	virtual void step(StepFlag flag = StepAll);
	virtual void step(StepFlag flag = StepAll) = 0;


	virtual void read_frame() = 0;
	virtual void build() = 0;
	virtual void step() = 0;
	

	virtual void read_frame();
	virtual void build();
	virtual void step();

void Slam::read_frame() {


	std::cout << "Slam::read_frame" << std::endl;

	Image* image = NULL;
	Image* resized = NULL;
	if(m_source->read(image)) {
		image->resize(resized);
		initialize(resized);
		replace_frame(resized);
	}
	if (image) { delete image; }
	if (resized) { delete resized; }

}

void Slam::build() {

}

void Slam::step() {

}



0.00047904194551971183	0.99452903207104948		-0.10445944134751967
0.030428648682743441	0.10439658562572		0.99407014352561363
0.99953682666430876		-0.0036547609378968881		-0.030212164178195087


0.75, -0.75, -0.116497561	21 9
1, 0, 0.129441738			22 9
1, 0, 0.116497561			23 9
0.25, 0.75, 0.220050961		33 9

-0, -1, -0.28477183			21 10
-0, 1, 0.28477183			33 10

-0, -1, -0.271827638		21 11
-0, 1, 0.271827638			33 11

-0, -1, -0.258883476		21 12
-0, 1, 0.258883476			33 12

-0, -1, -0.245939299		21 13
-0, 1, 0.245939299			33 13

-0, -1, -0.232995123		21 14
-0, 1, 0.232995123			33 14

-0, -1, -0.220050961		21 15
-0, 1, 0.220050961			33 15

-0, -1, -0.207106784		21 16
-0, 1, 0.207106784			33 16

-0, -1, -0.194162607		21 17
-0, 1, 0.194162607			33 17

-0, -1, -0.18121843			21 18
-0, 1, 0.18121843			33 17

-0, -1, -0.168274254		21 19
-0, 1, 0.168274254			33 19

-0, -1, -0.155330092		21 20
-0, 1, 0.155330092			33 20

-0.75, -0.75, -0.213578865	21 21
-1, 0, -0.129441738			22 21
-1, 0, -0.116497561			23 21
-0.25, 0.75, 0.11002548		33 21






--------------------u
0.00011543112911504532 0.99097710543201478    -0.13403120228230403
0.99999791864976828    0.00038741102398295743 -0.0020031497272539238
0.0020370006837826969 -0.13403069209059529     0.99097508758087882


----------------------vt-------------------
 0.00011543112911537083 0.99999791864976817     0.0020370006837827402
-0.99097710543201478    0.00038741102398194051 -0.13403069209059532
-0.13403120228230403   -0.0020031497272539234   0.99097508758087871



(gdb) x/9fg svd.u.data
0xafa500:	0.00011543112911504532	-0.99097710543201478
0xafa510:	-0.13403120228230403	0.99999791864976828
0xafa520:	0.00038741102398295743	-0.0020031497272539238
0xafa530:	0.0020370006837826969	-0.13403069209059529
0xafa540:	0.99097508758087882


(gdb) x/9fg svd.vt.data
0xafa140:	0.00011543112911537083	0.99999791864976817
0xafa150:	0.0020370006837827402	-0.99097710543201478
0xafa160:	0.00038741102398194051	-0.13403069209059532
0xafa170:	-0.13403120228230403	-0.0020031497272539234
0xafa180:	0.99097508758087871


(gdb) x/9fg svd.w.data
0x9cf260:	0.010807123924141982	0.0034913122732963915
0x9cf270:	0.00034598942193630252	2.3176438028923198e-310
0x9cf280:	3.1620201333839779e-322	1.4278497164812025e-321
0x9cf290:	2.3178011315328348e-310	2.3177869191898742e-310
0x9cf2a0:	7.9050503334599447e-323

